<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-09-29T21:00:34-03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Allan Vital</title><subtitle>Software Development and overall Problem Solving. &lt;a href=&quot;/about&quot; target=&quot;_blank&quot;&gt;More about me&lt;/a&gt;.</subtitle><author><name>Allan Vital</name></author><entry><title type="html">5 Reasons Why You Should NOT Rewrite Your System</title><link href="http://localhost:4000/5-reasons-why-you-should-not-rewrite-your-system" rel="alternate" type="text/html" title="5 Reasons Why You Should NOT Rewrite Your System" /><published>2018-01-21T22:18:25-02:00</published><updated>2018-01-21T22:18:25-02:00</updated><id>http://localhost:4000/5-reasons-why-you-should-not-rewrite-your-system</id><content type="html" xml:base="http://localhost:4000/5-reasons-why-you-should-not-rewrite-your-system">&lt;p&gt;After many years working in your system, building, tinkering, improving, breaking and reassembling, you decide that what is really needed is a full software rewrite. After all, what can go wrong?&lt;/p&gt;

&lt;p&gt;If you were ever involved in a full rewrite project, you know the answer. Absolutely everything can go wrong.&lt;/p&gt;

&lt;h2 id=&quot;why-you-think-you-want-it&quot;&gt;Why you think you want it&lt;/h2&gt;

&lt;p&gt;There’s plenty of reasons for developers to advocate for a full software rewrite, but the most common is the software complexity and cost of maintenance. This translates to “the system is so complex/bad written that it is impossible to effectively fix it without rewriting everything”.&lt;/p&gt;

&lt;p&gt;It actually makes a lot of sense, so much that I’ve already written a blog post &lt;a href=&quot;http://allanvital.com/your-system-is-born-to-die/&quot;&gt;guaranteeing that your software will be rewritten&lt;/a&gt;. Today I still think that this is the case, but, instead of focusing on full rewrites, &lt;strong&gt;we should strive for more refactoring&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Emphasis: as a rule of thumb you should never push for a full system rewrite.&lt;/p&gt;

&lt;h2 id=&quot;why-you-shouldnt-do-it&quot;&gt;Why you shouldn’t do it&lt;/h2&gt;

&lt;h4 id=&quot;1-the-estimates-will-be-wrong-by-a-large-margin&quot;&gt;1. The estimates will be wrong by a large margin&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://allanvital.com/why-estimates-never-work/&quot;&gt;Have I told you how hard it is to give good estimates?&lt;/a&gt; In software rewrites, they tend to be even worse than in normal circumstances. The main reason for this is simple: we usually focus on the areas we know that need to be worked, but rarely have a full understanding of important details inside a software (for any real-world system, it is almost impossible to know everything that is happening under the hood).&lt;/p&gt;

&lt;p&gt;The estimate problem is even worse in this scenario because, given the approval for a full rewrite, &lt;strong&gt;stakeholders will be extra picky about the project evolution.&lt;/strong&gt; Usually, the programmers need to make big promises about dates and results, which will inevitably lead to disappointment and badly managed expectations.&lt;/p&gt;

&lt;h4 id=&quot;2-knowledge-and-bug-fixes-will-be-thrown-away&quot;&gt;2. Knowledge and bug fixes will be thrown away&lt;/h4&gt;

&lt;p&gt;There are two main reasons for “bad written software”: the first one is bad design. The second one is bug fixes. Although sometimes it is hard to tell them apart, it is an important distinction in weighing the pros and cons of a full rewrite. It’s hard to argue positively for bad design, but even if this is the case, are you sure that the whole system is fundamentally broken, or are there isolated islands of terrible decisions? Because the second one doesn’t sound a good excuse for a full rewrite.&lt;/p&gt;

&lt;p&gt;Bug fixes, on the other hand, can turn maintenance work harder because it usually brings some trail of code smells, like methods that are larger than they should or extra boolean conditions, making it harder to read the code. This is usually called “bad code”, but it is necessary to keep in mind that they also are the knowledge base of your software.&lt;/p&gt;

&lt;p&gt;Reading software is a lot harder than writing, that is why sometimes you don’t see reason in some code chunk, but simply &lt;strong&gt;throwing it away is throwing real-world time spent&lt;/strong&gt; in bug fixing. Also, code running in production is battle-tested code. There is a high chance that given time, you’ll need to add the same checks to your new software because things broke in production.&lt;/p&gt;

&lt;h4 id=&quot;3-time-spent-in-the-rewrite-can-be-focused-on-the-improving-of-the-existing-software&quot;&gt;3. Time spent in the rewrite can be focused on the improving of the existing software&lt;/h4&gt;

&lt;p&gt;So, after arguing your best you got the green light for a full rewrite. How long will it take? Four months? Cool. Just one thing:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How much can you better the existing software in four months, instead of a full rewrite?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If your answer is “None!”, it means that you know nothing about the project yet.&lt;/p&gt;

&lt;p&gt;The first reaction to an old code base is an urgent necessity to rewrite it. This usually happens because we don’t know what is what in that project, and rewriting it will bring us to control again. But is it a rational thought? The optimal decision, usually, is to give time to mature the code in your head and try to understand what brought things to the actual state. After this, it is possible to, at least, improve things a little. And if this goes well, improve another little. And them, a little more.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;That’s how good software is made/fixed.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-you-wont-bring-anything-new-for-clients-or-stakeholders-even-if-successful&quot;&gt;4. You won’t bring anything new for clients or stakeholders, even if successful&lt;/h4&gt;

&lt;p&gt;The hardest part of a rewrite is the idea that you will be working a lot to deliver the very same thing that your customers and stakeholders already got. Of course, there will be some performance improvements or better UI, but the core features and works will (or should) remain similar. It is a rewrite after all.&lt;/p&gt;

&lt;p&gt;Another thing to keep in mind is that, in some projects, &lt;strong&gt;during the time in which you rewrite your software, you are a sitting duck for your competition.&lt;/strong&gt; While you rewrite and rewrite, your competitors will keep improving and adding new features. What’s keeping your clients in your system: the new beautiful code or built and tested software?&lt;/p&gt;

&lt;h4 id=&quot;5-its-an-endless-cycle&quot;&gt;5. It’s an endless cycle&lt;/h4&gt;
&lt;p&gt;Even if you tackled a full rewrite and all goes well and everybody is happy. &lt;strong&gt;What’s keeping the next dev in this project to advocate for a full software rewrite again?&lt;/strong&gt; How does one end this?&lt;/p&gt;

&lt;p&gt;Can you possibly improve things if you are only rewriting existing features? How much work will it take to keep the legacy working while you build the next big thing? What of the new things to add? Will they be frozen until you finish the new one?&lt;/p&gt;

&lt;h4 id=&quot;bonus-never-rewrite&quot;&gt;Bonus: Never rewrite?&lt;/h4&gt;

&lt;p&gt;There are, of course, times in which a full rewrite is mandatory. Sometimes the software is too broken, or too complex to maintain that you must fix the plane while it is in the air. The main tips for this are to keep everyone on the same page, showing why it is a good decision and, obviously and as always, manage the expectations. Tinker your estimates and keep an updated backlog of what is left to do. Show how you are improving things in the new software using real-world problems that you are solving (preferably, problems that haunted the legacy one). As long as everyone is aboard the rewrite train, you can be reassured that it was the right decision.&lt;/p&gt;

&lt;p&gt;If it is possible to delete and create your project in one month (that is your estimate? It will take six. Believe me), and there is support from upper management and areas outside TI, you should go for it.&lt;/p&gt;

&lt;p&gt;But do not say that I did not warn you.&lt;/p&gt;</content><author><name>Allan Vital</name></author><category term="software-rewrite" /><category term="software" /><category term="refactor" /><category term="software-refactoring" /><summary type="html">After many years working in your system, building, tinkering, improving, breaking and reassembling, you decide that what is really needed is a full software rewrite. After all, what can go wrong?</summary></entry><entry><title type="html">Know Your Language: Java Pitfalls</title><link href="http://localhost:4000/know-your-language-java-pitfalls" rel="alternate" type="text/html" title="Know Your Language: Java Pitfalls" /><published>2017-09-28T13:45:59-03:00</published><updated>2017-09-28T13:45:59-03:00</updated><id>http://localhost:4000/know-your-language-java-pitfalls</id><content type="html" xml:base="http://localhost:4000/know-your-language-java-pitfalls">&lt;p&gt;&lt;em&gt;Let’s get more technical. ‘Know your Language’ is a new category in my blog, about Programming Languages and their most common problems in enterprise environments&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&quot;https://www.tiobe.com/tiobe-index/&quot;&gt;Tiobe&lt;/a&gt; Java is the most used backend programming language of the world. According to &lt;a href=&quot;https://insights.stackoverflow.com/survey/2017#technology&quot;&gt;StackOverflow&lt;/a&gt;, this title goes to Javascript, but Java gets third place. Java and the JVM are also almost omnipresent in mobile, with Android using it as a platform.&lt;/p&gt;

&lt;p&gt;It is adopted by major companies and there are a lot of job openings for it. Also, you can always find some tool or framework that solves that particular problem you are facing, given it’s huge history and fame.&lt;/p&gt;

&lt;p&gt;It is also extremely verbose, prone to code bloat, low level (compared with newer languages), clunky all around and resource-eating.&lt;/p&gt;

&lt;p&gt;I know that all boils down to “there are bad programs in all languages”, but I believe that there are design details of each language that puts developers in a easy position to fall down in some traps, specially considering that we usually tend to “follow the guidelines” of the gurus.&lt;/p&gt;

&lt;p&gt;Sticking to code and design, let’s see what are the most common pitfalls I’ve seen in Java projects.&lt;/p&gt;

&lt;h4 id=&quot;complex-build&quot;&gt;Complex Build&lt;/h4&gt;
&lt;p&gt;Pretty simple. You do your clone, access the directory and do a build command&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./gradlew build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And then it fails.&lt;/p&gt;

&lt;p&gt;Usually this means an environment dependency or a manually added hosts to run the build or tests. Unless your build actually runs in a single command, you are doing it wrong.&lt;/p&gt;

&lt;p&gt;Gradle is a specially offender in this case because of the easiness to create customized tasks. Avoid overly &lt;em&gt;romantic&lt;/em&gt; tasks and approaches, like code generation.&lt;/p&gt;

&lt;h4 id=&quot;thrown-design-patterns&quot;&gt;Thrown Design Patterns&lt;/h4&gt;

&lt;p&gt;The idea behind a design pattern is somewhat simple: You have a recurrent problem and a design pattern is a known way to solve that problem. Pretty straightforward, Problem leads to Solution. The issues arise when you like one solution and tends to apply it anywhere you see fit (the old &lt;a href=&quot;https://en.wikipedia.org/wiki/Law_of_the_instrument&quot;&gt;“when all you have is a hammer, everything looks like a nail”&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Simple example, a Strategy Pattern. In cool words Strategy is a way that enables algorithm selecting at runtime. In common terms, it is used to hide an “if” statement.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Strategy_pattern&quot;&gt;Wikipedia example:&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Interface with price calculation&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface BillingStrategy {
    double getActPrice(final double rawPrice);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First implementation&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class NormalStrategy implements BillingStrategy {
    @Override
    public double getActPrice(final double rawPrice) {
        return rawPrice;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Second implementation&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class HappyHourStrategy implements BillingStrategy {

    @Override
    public double getActPrice(final double rawPrice) {
        return rawPrice*0.5;
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We could have our customer class:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Customer {
    /* fields */
    public Customer(final BillingStrategy strategy) {
        this.drinks = new ArrayList&amp;lt;Double&amp;gt;();
        this.strategy = strategy;
    }

    public void add(final double price, final int quantity) {
      drinks.add(strategy.getActPrice(price*quantity));
    }

    public void setStrategy(final BillingStrategy strategy) {
        this.strategy = strategy;
    }

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And now we can use it neatly:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class StrategyPatternWiki {

    public static void main(final String[] arguments) {
        Customer firstCustomer = new Customer(new NormalStrategy());

        // Normal billing
        firstCustomer.add(1.0, 1);

        // Start Happy Hour
        firstCustomer.setStrategy(new HappyHourStrategy());
        firstCustomer.add(1.0, 2);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cool right? How can it be bad? Let’s apply this everywhere!&lt;/p&gt;

&lt;p&gt;But there is a catch, even in this simple example. How do I know when to use HappyHourStrategy or NormalStrategy? Can I hide this specific if with another strategy? If yes, would it be better than a single if? Maybe, instead of this, I could add in the customer class:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Customer {
...
    public void add(final double price, final int quantity) {
        drinks.add(floatingPriceCalculator.getCurrentPrice(price*quantity));
    }
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And then&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class FloatingPriceCalculator {
    public double getCurrentPrice(final double rawPrice) {
        if (isHappyHourTime()){
           return rawPrice * 0.5;
        } else {
           return rawPrice;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is it so bad? You’re making the decision in a single IF-ELSE instead of building an indirection layer, and besides it, still in a single point, in case you need to refactor or read it. If this if else grow in number, maybe it is time to refactor, but right now, I think it is good enough.&lt;/p&gt;

&lt;p&gt;Design patterns are tools, not the only way to do something.&lt;/p&gt;

&lt;h4 id=&quot;functional-interface-misuse&quot;&gt;Functional Interface Misuse&lt;/h4&gt;

&lt;p&gt;Functional interfaces are awesome. It can really make your code more elegant and simple. Let’s take a look, using &lt;a href=&quot;https://www.oreilly.com/learning/java-8-functional-interfaces&quot;&gt;OReilly&lt;/a&gt; as a resource.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@FunctionalInterface
public interface Runnable {
  public void run();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In the old days, we would use it like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Thread thread1 = new Thread(new Runnable() {
    @Override
    public void run(){
        System.out.println(&quot;Run now!&quot;);
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;With Java8 and Lambdas, the compiler knows that you are calling the single method from the functional interface.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Runnable task1 = () -&amp;gt; { System.out.println(&quot;run you damn!&quot;); };
new Thread(task1).start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Neat, right? The “()” syntax is useful because you can just pass the arguments there and the compiler knows the types.&lt;/p&gt;

&lt;p&gt;The problems arise when you try to build a DSL for fluent language with this, because nowadays you see things like:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;maClass.needDoThis()
       .AndThis()
       .withALittleBitOfThis()
       .andNowDone();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And to build this, you create a single functional interface for each of the dots, like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface AndThis {
    LittleBitOfThis andThis();
}
public interface LittleBitOfThis {
    AndThis withALittleBitOfThis();
}
public interface NowDone {
    void andNowDone();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And in maClass.needDoThis() you get:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MaClass{
    public void needDoThis() {
        () -&amp;gt; () -&amp;gt; () -&amp;gt; {
           //do a lot of things
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I’ve seen it more than once. Don’t do this. You created a lot of complication just to make a pretty oneliner, which, in the end, is just a single method anyway. Wouldn’t be easier if you just called the method?&lt;/p&gt;

&lt;h4 id=&quot;poor-or-overused-oo&quot;&gt;Poor (or overused) OO&lt;/h4&gt;

&lt;p&gt;I know that this is possible in any OO language, but Java suffers it hard. There’s a lot of confusion about concepts like composition over inheritance, or loose coupled parts or plain simple class design, and big problems arise from this confusion.&lt;/p&gt;

&lt;p&gt;(Java8 default methods in interfaces made this even more common)&lt;/p&gt;

&lt;p&gt;A great smell of bad class design is the &lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof&lt;/code&gt; operator used a lot. It, of course, has its uses, but always think through when you use it to check if your design is OO adherent.&lt;/p&gt;

&lt;p&gt;A bad example from &lt;a href=&quot;https://stackoverflow.com/a/13292073/3632899&quot;&gt;StackOverflow&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Cage {
  public static Cage createCage(Animal animal) {
    if (animal instanceof Dog)
      return new DogHouse();
    else if (animal instanceof Lion)
      return new SteelCage();
    else if (animal instanceof Chicken)
      return new ChickenWiredCage();
    else if (animal instanceof AlienPreditor)
      return new ForceFieldCage();
    else
      return new GenericCage();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You could replace and put the responsibility inside the Animal interface:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Animal {
  Cage getCage();
}

class Dog implements Animal {
  ...
  public Cage getCage() {
    return new DogCage();
  }
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(I know, it’s just an academic example, but you got the idea)&lt;/p&gt;

&lt;p&gt;In the other side of the spectrum, &lt;a href=&quot;https://blog.codinghorror.com/your-code-oop-or-poo/&quot;&gt;there’s the overly complex class design&lt;/a&gt;, which should also be avoided.&lt;/p&gt;

&lt;h4 id=&quot;reflection&quot;&gt;Reflection&lt;/h4&gt;
&lt;p&gt;Reflection is one of the most powerful features of Java. You can, basically, access anything at runtime, even modify the methods or fields. The majority of frameworks use it to be able to call your code using the conventions of the language (getters and setters. How do you think hibernate fills your fields?).&lt;/p&gt;

&lt;p&gt;Again, the problem with it is the layer of abstraction that you put in your code. When you use reflection, your errors will be in runtime, and your IDE will not be able to help you with the “find usages”. You are basically on your own.&lt;/p&gt;

&lt;p&gt;As a rule of thumb, use Reflection to build frameworks, &lt;a href=&quot;https://www.quora.com/Whats-the-difference-between-a-library-and-a-framework/answer/Kurt-Guntheroth-1?srid=oiBW&quot;&gt;because they need to be able to call yet nonexistent code&lt;/a&gt;. To build your applications, avoid it always.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://examples.javacodegeeks.com/core-java/reflection/java-reflection-example/&quot;&gt;There are some examples here, and you can see why it is so bad.&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;aspect-overuse&quot;&gt;Aspect Overuse&lt;/h4&gt;

&lt;p&gt;I think that this one is the most “personal” problem, because I see a lot of people praising AOP and the benefits of AspectJ, but I find myself enjoying it less and less as time passes. Right now I wouldn’t use it in application code, but, as it is with reflection, it is useful for framework creation.&lt;/p&gt;

&lt;p&gt;One of the main reasons why I think it is harmful is for debugging. You came across a legacy system with a bug and you catch a glimpse of the log:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2017-05-25 00:22:31.496  INFO 1 --- [Thread-3] maProject.maPackage.maClass1 : Trying to do something
2017-05-25 00:22:31.512  INFO 1 --- [Thread-2] maProject.maPackage.maClass2 : I shoudn't be trying this, but I am nonetheless
2017-05-25 00:22:31.530  INFO 1 --- [Thread-3] maProject.maPackage.maClass3 : Continuing ok, nothing to see here
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cool, maClass2 seems to be the aggressor. Then you open the class and don’t find the log line. And don’t see where maClass1 is calling maClass2. And neither the call to maClass1. Everything is build around aspects, and your whole project is a huge collection of indirection layers, one after another.&lt;/p&gt;

&lt;p&gt;Avoid it. It is not harmful to see a &lt;code class=&quot;highlighter-rouge&quot;&gt;log.info(&quot;&quot;)&lt;/code&gt; inside your method.&lt;/p&gt;

&lt;p&gt;Sometimes it is better to be straightforward than clever.&lt;/p&gt;

&lt;h4 id=&quot;ejb-2&quot;&gt;EJB 2&lt;/h4&gt;

&lt;p&gt;Just don’t. I mean it.&lt;/p&gt;</content><author><name>Allan Vital</name></author><category term="know-your-language" /><summary type="html">Let’s get more technical. ‘Know your Language’ is a new category in my blog, about Programming Languages and their most common problems in enterprise environments</summary></entry><entry><title type="html">What defines a good Software Developer?</title><link href="http://localhost:4000/what-defines-a-good-software-developer" rel="alternate" type="text/html" title="What defines a good Software Developer?" /><published>2017-09-06T14:44:51-03:00</published><updated>2017-09-06T14:44:51-03:00</updated><id>http://localhost:4000/what-defines-a-good-software-developer</id><content type="html" xml:base="http://localhost:4000/what-defines-a-good-software-developer">&lt;p&gt;There are hundreds of interview techniques, thousand of tools, each with a corresponding required knowledge to work with, countless “classic” algorithms and a myriad of different types of projects to try to evaluate a Software Developer. Yet, it is not easy to, nor formally or mathematically, separate a good Developer from a bad one. Why?&lt;/p&gt;

&lt;p&gt;As always, there’s no easy answer to this question. The main reason for this is, perhaps, that we don’t know what a Software Developer actually does. Software creation is not a mechanical task, and, even if it was, writing software, in many cases, is &lt;strong&gt;not&lt;/strong&gt; the main assignment of a software developer.&lt;/p&gt;

&lt;p&gt;Even identifying this problem is a matter of debate. Saying that the main job of a Software Developer is not to develop software will surely raise a discussion, and I can understand that. But I think the real issue is that, even if we agree with this, we don’t know what “develop software” actually is. Is it writing a program? Is it finding the right tool for the task? Is it debugging a system? And, if you answer “All of the above”… well, how do you measure each one of these? If you can’t measure, you can’t categorically say who is a good Developer.&lt;/p&gt;

&lt;h4 id=&quot;levels-of-education-and-formal-knowledge&quot;&gt;Levels of education and formal knowledge&lt;/h4&gt;

&lt;p&gt;One of the most basic ways to filter job applicants is to evaluate their formal knowledge of computer science. That’s when we give a test asking things about algorithm complexity or ask some classic sorting problem.&lt;/p&gt;

&lt;p&gt;This fails on some levels. Even though knowledge of these is good, there are a lot of jobs in which the applicant would never use it in the company. Why bother asking about merge sort if the main assignment will be a simple CRUD application? Further still, if it’s not a pressing issue, why can’t you hire and teach?&lt;/p&gt;

&lt;p&gt;That kind of evaluation brings the worst type of interview: “Write in the white board a quick sort”. If you failed in memorize all those 28 “classic code interview question”, you failed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X&quot;&gt;I really, really, really hate the idea that you will need to read a book&lt;/a&gt; just to pass in an interview for a job. And, the worst thing is: even if your applicant can solve these problems at point blank, it’s not guaranteed that he will perform good with the stack and tool set of your environment.&lt;/p&gt;

&lt;h4 id=&quot;tooling-knowledge&quot;&gt;Tooling knowledge&lt;/h4&gt;

&lt;p&gt;Every software developer worth his salt has some stack or tools in which they are comfortable. Better still, they should have lots of tools in their skill set, because this avoids the common pitfall in which “when your only tool is a hammer, everything looks like a nail”.&lt;/p&gt;

&lt;p&gt;But, as I said before, &lt;a href=&quot;http://allanvital.com/be-careful-with-the-right-tool-for-the-right-job/&quot;&gt;we should always be careful about the right tool for the right job&lt;/a&gt;. Besides, relaying only in tooling you will miss good fits just because they don’t know some of the tools used in your environment.&lt;/p&gt;

&lt;p&gt;And when all is said and done, how do you measure if a software developer knows how to use some tool? They might have learned it, read it somewhere, but might fail in actually using it in a real world problem. We go back to the “what actually you do?”.&lt;/p&gt;

&lt;h4 id=&quot;different-performance-in-different-companies&quot;&gt;Different performance in different companies&lt;/h4&gt;

&lt;p&gt;Another problem of the measuring job is that a good Software Developer in company A can be a terrible Software Developer in company B. Even if these companies share the same technological stack. There are countless ways that a company differs from another, and every one of these can hinder the performance of a software developer.&lt;/p&gt;

&lt;p&gt;Take a “Good” developer from a big company. He must be able to survive the bureaucracy to bring his problem solving skills to the table. He might not be the brightest coder, but he will be able to thrive and bring results in such environment.&lt;/p&gt;

&lt;p&gt;On the other hand, a “Good” developer from a small company will probably need to be fast in delivering features. He might not build the most maintainable systems in the long run, but will surely be the best bet in this scenario.&lt;/p&gt;

&lt;p&gt;(both scenarios are completely hypothetical. Any similarity with reality is pure coincidence)&lt;/p&gt;

&lt;p&gt;If we exchange the developers, there is a high change that they will be labeled as “Bad” developers in each company, even with equal tooling, stack and technical knowledge. Worse, there is a high change that both will not tolerate the work conditions.&lt;/p&gt;

&lt;p&gt;(of course, we could find the so famous “rock star developer” that can operate in every level of any company of any size… but it’s a really rare fish)&lt;/p&gt;

&lt;h4 id=&quot;teams&quot;&gt;Teams&lt;/h4&gt;

&lt;p&gt;After we fail to measure what is a good software developer, we reach the next level of difficulty: we usually work in teams, and, even though teams are the sure way to build something sustainable and good, it is also one of the easier ways to go “under the radar”. If your team of four developers are delivering good, how can you know which one are performing great and which ones are poorer? This is necessary for a lot of reasons, that goes from training to promotions and raises.&lt;/p&gt;

&lt;p&gt;This one is specially hard. If one of the developers commit less code (crappy metric, I know), is it because he is not working right, or is it because he is helping and pairing with the others? Worse still, is he heroically interfacing with the stakeholders and breaking the features in technical tasks? Is he correcting the delivery pipeline? Or is he… bad? (some of these are actually measurable, I know, but in some cases it is not that simple).&lt;/p&gt;

&lt;p&gt;Also, teams are organically complex beings. What makes a team good is not easily definable (probably as hard as defining a good software developer), and team members that perform really well in one can be the drawback in another. Does that mean that this player were bad all along, or does this mean that he doesn’t fit with the new environment? How can you answer this question?&lt;/p&gt;

&lt;h4 id=&quot;what-the-hell-does-a-software-developer-actually-do&quot;&gt;What the hell does a Software Developer actually do?&lt;/h4&gt;

&lt;p&gt;A ton of things, actually.&lt;/p&gt;

&lt;p&gt;In smaller environments (startups mostly) the software developer usually codes and ships a lot. When you are trying to get something out there fast, and your customer base is smaller enough, your main issue is to get new features and improving your product as fast as possible. Probably, your production issues won’t eat your whole time, and you might be able to extinguish fires and keep the quick production and shipping dates. In such experience, you will probably be measured in your tickets moved to “done” and your ability to solve production issues quick, in a way that doesn’t interfere with your coding speed.&lt;/p&gt;

&lt;p&gt;In medium sized companies (I draw the line at 100 employees) you will probably start to lose speed. In most cases, you will need to hire specific operation people for your production outages so that you can keep the developers focused in the tasks. You will also need other specific titles, people that can prioritize the best tasks and efforts, business analysts to understand the idea and plan new directions. Since the environment became more complex, your team will need to, besides the obvious code skills, start communicating with all these areas. It’s unfair to ask these people what is easier and faster to do inside your codebase, so, for them to be able to plan correctly, your team will start going to meetings and be able to explain it. Unfortunately you will need to start estimating your stories, which sometimes is overlooked in smaller companies. From coding and fire fighting, you now need people that can help business more closely, oiling the engines of the whole. Your dev team will need to interface with operations also, building solutions together, so the production environment keep sane and maintainable.&lt;/p&gt;

&lt;p&gt;For big companies, take the medium size problems and make them even bigger, and throw the famous legacy systems in the scenario. Your dev team will need to get reeeeeally good at documentation and communication and will need to learn the skills to handle the coordination of features delivery, the process needed to organize many teams working on the same code base and the overall complexity of all systems working together. In such an environment, you can see your dev team working in the whole company. Helping in the business decisions, estimating the deliverables and coordinating the the order in which to attack the tasks. Helping in the outages and improving the preventive maintenance to mitigate them. Oh, and also building new features.&lt;/p&gt;

&lt;p&gt;Given the huge mutability of the job description, one question comes back.&lt;/p&gt;

&lt;h4 id=&quot;how-do-you-measure&quot;&gt;How do you measure?&lt;/h4&gt;

&lt;p&gt;It is such a wide array of possibilities that it is almost impossible to mathematically judge who is a good or who is a bad developer. Joe might have fewer commits, but that is because he is teaching the less experienced ones. Julia fails at most of her estimates, but is the quicker to solve production outages. Bill is able to break the product area requests in nice sized histories. Mary is the most resourceful coder. Pan is the best code reviewer.&lt;/p&gt;

&lt;p&gt;The only way that worked in my experience, in both measuring the good developers and helping them improve was &lt;strong&gt;constant&lt;/strong&gt; feedback, both for pairs, and from the whole team.&lt;/p&gt;

&lt;h4 id=&quot;feedback&quot;&gt;Feedback&lt;/h4&gt;

&lt;p&gt;When it comes to feedback, the closer the better. For a single developer, it’s nice to have the feedback from another area, it’s important to have the feedback from another team, it’s necessary to have feedback from the manager and it’s vital to have from her/his pairs. It’s the manager job to collect these feedbacks to be able to evaluate her/him, and be able to mentor the individual to better themselves.&lt;/p&gt;

&lt;p&gt;I like the 360 feedback format, but it is too time consuming, making it almost impractical as a constant feedback loop. Besides, such a meeting can have a negative impact in more anxious people, therefore it is better to collect the information separately.&lt;/p&gt;

&lt;p&gt;For inter areas feedbacks, a message or email is “good enough”, if you don’t have the time. Send a message and politely ask about the team collaboration. Make it clear that it is for feedback purpose, and that, in this case, more information is better than less.&lt;/p&gt;

&lt;p&gt;For another team, message is good, but direct contact is better. Ask them the same questions and be clear about the objective. Take notes about opinions or problems raised.&lt;/p&gt;

&lt;p&gt;Inside the team, I like two formats. One open, which is sometimes called “Fast Feedback”, where the team meets and, in pairs, say the good points and the “points to be improved” one to another. The other one is closed, the team meets without the evaluated member and lists the same points. That is useful for team members that are too shy to criticize or the “good guys” that, given their social skills, it is hard to point problems face to face.&lt;/p&gt;

&lt;p&gt;With all this material in hand, it is possible to schedule one-on-ones meetings with the team members and face the problems or congratulate the performance. It’s possible to, even inside a team, assess individual performance. It’s a lot more personal than numbers, so there’s always chances of errors and mistakes, but it’s the closest thing you can get of real world developer performance.&lt;/p&gt;</content><author><name>Allan Vital</name></author><category term="developer-performance" /><category term="team-building" /><summary type="html">There are hundreds of interview techniques, thousand of tools, each with a corresponding required knowledge to work with, countless “classic” algorithms and a myriad of different types of projects to try to evaluate a Software Developer. Yet, it is not easy to, nor formally or mathematically, separate a good Developer from a bad one. Why?</summary></entry><entry><title type="html">About Software Estimates</title><link href="http://localhost:4000/why-estimates-never-work" rel="alternate" type="text/html" title="About Software Estimates" /><published>2017-07-22T22:13:44-03:00</published><updated>2017-07-22T22:13:44-03:00</updated><id>http://localhost:4000/why-estimates-never-work</id><content type="html" xml:base="http://localhost:4000/why-estimates-never-work">&lt;p&gt;There sure is a lot of &lt;a href=&quot;https://www.quora.com/Why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3&quot;&gt;talk and work about estimates in software development&lt;/a&gt;. Whether you are in a big company, a small agency or a “one-man army” project, the idea that you can predict how long will it take to build a system is widespread and adopted by all.&lt;/p&gt;

&lt;p&gt;Any management principle or project schedule has it as a bare minimum to operate. This is useful so you can plan in advance, and tackle the projects in a sane order, avoiding obvious trap holes and business errors. In a multiple-team environment, it is used to coordinate the deliverables in a way that one team does not block the other one, therefore mapping the dependencies and fitting the work appropriately.&lt;/p&gt;

&lt;p&gt;The only problem is that, in the majority of cases, software estimates are &lt;strong&gt;wrong&lt;/strong&gt;. Often, by a large margin.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.quora.com/Why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3&quot;&gt;It is probably one of the most analyzed problems in the industry&lt;/a&gt;, and yet, one of the most unresolved ones.&lt;/p&gt;

&lt;h3 id=&quot;the-elephant-in-the-room&quot;&gt;The Elephant in The Room&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://calleam.com/WTPF/?tag=examples-of-failed-it-project&quot;&gt;Software projects estimates fail hard since the dawn of software&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the old days, with methodologies like Waterfall, this problem was usually lost in the middle of the whole process. It was easy to blame the testers about the time it was taking to find bugs, and easier still to blame operations about the delays occurring during deploy attempts. The segmentation of the whole flow, and the idea that project time consisted mainly of “Coding Phase” kept the specific Feature Estimation problem hidden. Creating cross functional teams to solve this helped in the way of identifying and bringing the flawed process to light, but could do little in a months (or years) long project.&lt;/p&gt;

&lt;p&gt;The blooming of Agile, carried by Agile Manifesto, acknowledged this problem and created a lot of ways to deal with it. There are Fibonacci Sequences, T-Shirt Sized User Stories, Sprint Velocity and many others, and the idea of breaking whole projects in a series of small features minimized the problem, because, of course, a missed week estimate is a lot better than a month long one. Another brilliant improvement above the older methods is the reaction and prioritization brought to the table by a clear feature list in the hands of the product owner and stakeholders. Being able to change course during the so called “Building Phase” is, probably, the single most valuable lesson that Agile brought to the software world.&lt;/p&gt;

&lt;p&gt;(that we should always be on the “Building Phase” is a matter to another post)&lt;/p&gt;

&lt;p&gt;With the sum of cross functional teams, feature slicing and prioritization we were able to bring everyone involved in the process in a way that makes it clear the efforts of software building. With this, we could explain why feature X is taking so long to complete, and why team Y is performing good. The rate of deliveries and the delivered value of each part became clear and more palpable.&lt;/p&gt;

&lt;p&gt;However, the real, long time, projects, still miss the deadline. It is so widespread that some companies just don’t estimate anymore, and, even with the transparency of the whole process, we still struggle to find any sane method that brings some level (any level) of assertiveness.&lt;/p&gt;

&lt;h3 id=&quot;why-should-we-care&quot;&gt;Why Should We Care?&lt;/h3&gt;

&lt;p&gt;I’m a huge fan of the &lt;a href=&quot;http://manifesto.softwarecraftsmanship.org/&quot;&gt;Software Craftsman Manifesto&lt;/a&gt;. I think that, in the current state of the market, Software Development is closer to art than it is to science. Take ten developers and ask every one of them the same task. Watch as they will come to you in different times, with different questions about the task and completely different solutions, each one with some special weird moving part.&lt;/p&gt;

&lt;p&gt;(that is the reason why I think Software Developers, despite the stress, are &lt;a href=&quot;https://www.forbes.com/pictures/mkl45eeilm/no-6-happiest-job-software-developer/#4f7da09b6186&quot;&gt;usually happy with their occupation&lt;/a&gt;. Maybe not happy in their company, but happy with their craft)&lt;/p&gt;

&lt;p&gt;This is, obviously, a problem to any serious business. &lt;a href=&quot;http://www.nasdaq.com/article/the-importance-of-business-planning-cm59436&quot;&gt;Planning in advance, and most importantly planning assertively, is the difference between life and death of a company&lt;/a&gt;. This is the current way of calculating budget values, monitoring goals and defining a project success or failure, and failing to do so is what makes the “IT Department” the most complex to run in any kind of industry field.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_failed_and_overbudget_custom_software_projects&quot;&gt;Failing to bring any type of real and assertive estimates is an industry wide fail and hurts all sectors that depend on software&lt;/a&gt; (in today’s world, that is “all sectors”). Solving it, or just improving it a little, would bring us closer to more mature forms of engineering.&lt;/p&gt;

&lt;p&gt;(That’s why I usually avoid the term “Software Engineer”, but that is also a topic for another post)&lt;/p&gt;

&lt;h3 id=&quot;industry-approaches-so-far&quot;&gt;Industry Approaches So Far&lt;/h3&gt;

&lt;p&gt;As said above, the Agile Manifesto addressed this issue and brought some ways to mitigate it. I’ll list bellow some of the approaches that I experienced, and my opinion about them.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fibonacci_scale_(agile)&quot;&gt;Fibonacci Points&lt;/a&gt;&lt;/strong&gt;: The most raw form of small time estimate. Scrum popularized it. The main problem with this one is that a 13 sized story is not the same than two 5s and one 3 (!). That is why it doesn’t help in measuring the team velocity, therefore, failing to bring any type of assertiveness.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.codeproject.com/Articles/18024/Calculating-Function-Points&quot;&gt;Function Points&lt;/a&gt;&lt;/strong&gt;: This one is really complicated and… well, bad. It calculates a number that symbolizes the complexity of the requirements, based on user inputs and outputs and external interfaces (among other things). Since user inputs are one different from another, and external interfaces are hugely different among each other (try to integrate with a Rest and a Soap web service and tell me how long will each one take) the number always fails.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Stories of same size&lt;/strong&gt;: Try to slice your stories all in a similar size so you can take a median of the time spent in each. This way you will know that if a project has X stories, it’ll take X * time per story to finish. The tricky part is: “How to slice stories in the same size?”&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.mountaingoatsoftware.com/blog/estimating-with-tee-shirt-sizes&quot;&gt;T Shirt Sizes&lt;/a&gt;&lt;/strong&gt;: More sane than Fibonacci points, because a &lt;em&gt;M&lt;/em&gt; sized story is not the same size than two &lt;em&gt;P&lt;/em&gt; sized ones. However this brings two problems: identifying the difference between a &lt;em&gt;M&lt;/em&gt; and a &lt;em&gt;G&lt;/em&gt; (and so on) and calculating the appropriate sprint size. Simply put, if your team spent three months doing only &lt;em&gt;M&lt;/em&gt; sized ones, now that you only have &lt;em&gt;G&lt;/em&gt;s, how many ones they can tackle this month?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;There is no simple solution to the problem, but the best way to mitigate it is to break the work in small steps. Personally, I don’t like to break it too small, because every story has an overhead in the process (that is, a story that is just a character change will take longer to write and validate than it is worth), but a “less than a week” size is good enough.&lt;/p&gt;

&lt;p&gt;In my experience, it is worth to try to break the stories in the same size, or the most close to it possible. The main caveat is that developers will need to help slice the stories, because they are the only ones capable (since they know the system internals). You will also need to be OK with not optimal slices in favor of predictability.&lt;/p&gt;

&lt;p&gt;Also, it all come down to expectation management. Make clear to everyone involved the plans and milestones. When stories start to prolong beyond expected, reexamine the problem and estimates. Broadcast the walkthrough. This way, the stakeholders can plan and react accordingly.&lt;/p&gt;

&lt;p&gt;It sure doesn’t solve the problem, but mitigate it and turns the process in a healthy and transparent one.&lt;/p&gt;</content><author><name>Allan Vital</name></author><category term="project-management" /><category term="estimates" /><summary type="html">There sure is a lot of talk and work about estimates in software development. Whether you are in a big company, a small agency or a “one-man army” project, the idea that you can predict how long will it take to build a system is widespread and adopted by all.</summary></entry><entry><title type="html">Leader Election Using Spring-Boot</title><link href="http://localhost:4000/leader-election-using-spring-boot" rel="alternate" type="text/html" title="Leader Election Using Spring-Boot" /><published>2016-11-08T03:53:00-02:00</published><updated>2016-11-08T03:53:00-02:00</updated><id>http://localhost:4000/leader-election-using-spring-boot</id><content type="html" xml:base="http://localhost:4000/leader-election-using-spring-boot">&lt;p&gt;Warning: technical post ahead. You may want to take the children out of the room!&lt;/p&gt;

&lt;p&gt;Spring-boot took the market by storm in the last years. Spring, as is, &lt;a href=&quot;http://www.indeed.com/jobtrends/q-Spring-Framework-q--J2EE-q--Java-EE-q--Java.html?relative=1&quot;&gt;with MVC dependency had already bitten a huge chunk of job posts and online questions&lt;/a&gt;, but with the Boot simplicity, it practically set the new standart for frameworks in Java language. With it’s auto-configuration features and &lt;a href=&quot;https://start.spring.io/&quot;&gt;spring initiatizr&lt;/a&gt; , projects setup now takes seconds.&lt;/p&gt;

&lt;p&gt;But all simplicity comes with a price: It’s hard to do some simple customized thing outside the framework. Maybe not hard, but when you become accustomed with blindly easy property setting, all complication gets frustrating. That’s how it began my small quest.&lt;/p&gt;

&lt;p&gt;I was testing some features for a new project at work and one of the many ideas was to, given a number of spring nodes, without intervention, set one node as a leader to run a background job. Simple as that. It’s called &lt;a href=&quot;https://en.wikipedia.org/wiki/Leader_election&quot;&gt;Cluster Leadership Election&lt;/a&gt;, and it’s a commom problem in many clusterized environments (&lt;a href=&quot;http://redis.io/topics/sentinel&quot;&gt;Redis&lt;/a&gt; among others).&lt;/p&gt;

&lt;p&gt;Spring philosophy is to keep your server stateless, therefore there’s no need for election process, since the n nodes of your application are not exactly clusterized, in the way that they are not aware of each other. It’s great for horizontal scalling, and I believe it’s one of the “spring ways of life” wich brought it to the top. But in my case, all I wanted was a simple way to keep the nodes aware if they are or not the leader.&lt;/p&gt;

&lt;p&gt;Searching the documentation, I’ve first come across &lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-cluster/tree/master/spring-cloud-cluster-hazelcast&quot;&gt;Leadership Election with Hazelcast Spring Cloud Cluster&lt;/a&gt;, but oops, it’s Deprecated in favour of &lt;a href=&quot;https://projects.spring.io/spring-integration/&quot;&gt;Spring-Integration&lt;/a&gt;. I started looking at this one instead, but it was an immense overkill for my use case. I didn’t need complex interations between my nodes, neither needed grand integrations between many different protocols. Dead end.&lt;/p&gt;

&lt;p&gt;The other way I’ve found was to use &lt;a href=&quot;https://zookeeper.apache.org/&quot;&gt;ZooKeeper&lt;/a&gt;. It is an awesome project, which has by default the &lt;a href=&quot;https://zookeeper.apache.org/doc/trunk/recipes.html#sc_leaderElection&quot;&gt;Leadership Election&lt;/a&gt; that I so much needed. But, again, setting up a ZooKeeper cluster seemed a big step to execute something simple. I didn’t need service discovery and the many more features it brings to the table. Seemed like a cannon to kill an ant. Discarded.&lt;/p&gt;

&lt;p&gt;Besides these two I found… nothing. It was really difficult finding someone with the same problem, and, when I found, they usually built something big and complex, with database tables and the sort. Not the idea of quick and simple that I had in mind.&lt;/p&gt;

&lt;p&gt;So, &lt;a href=&quot;https://github.com/vitallan/redis-leader-by-lock&quot;&gt;I built one myself&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Using redis set to create a lock registry, the idea is: Whoever holds the lock, is the leader. This is somewhat different from other implementation where the oldest node is the leader until shutdown, because the leadership can go from node to node depending on the lock ping and the lock timout, but scratched my itch. It is simple, with easy configuration, reliable and expandable.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/vitallan/redis-leader-by-lock&quot;&gt;Feel free to use it&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It’s nice to test it in, say, four different terminals. That way you can kill and spawn the proccess and check it’s own organization to define the leader and change it. One improvement would be to randomize the fixed delays and check the behaviour. I will do this test in a near future.&lt;/p&gt;

&lt;p&gt;Please, oh please, if you find any bug or problem, &lt;a href=&quot;https://github.com/vitallan/redis-leader-by-lock/issues&quot;&gt;let me know&lt;/a&gt;.&lt;/p&gt;</content><author><name>Allan Vital</name></author><summary type="html">Warning: technical post ahead. You may want to take the children out of the room!</summary></entry><entry><title type="html">Your software will be rewritten</title><link href="http://localhost:4000/your-system-is-born-to-die" rel="alternate" type="text/html" title="Your software will be rewritten" /><published>2016-02-22T16:00:00-03:00</published><updated>2016-02-22T16:00:00-03:00</updated><id>http://localhost:4000/your-system-is-born-to-die</id><content type="html" xml:base="http://localhost:4000/your-system-is-born-to-die">&lt;p&gt;So, there’s this thing about your system.&lt;/p&gt;

&lt;p&gt;It’s born to die.&lt;/p&gt;

&lt;p&gt;I’m talking more specifically about the Web Systems, because that’s my area of expertise, but it’s valid for several areas of software development. Systems are created to be destructed in the long run. And that’s okay.&lt;/p&gt;

&lt;p&gt;I’ll explain myself.&lt;/p&gt;

&lt;p&gt;If you already worked in some big project, or for some years in a company, you already saw what people call Legacy Code. It’s more common known as that code that runs in production for so long that people don’t know anymore how it works. Sometimes these legacy systems hold the very core features of a company, which every other satellite system will depend on. In this case we have some terryfing scenario in play: my “fundamental stone” works, but nobody knows exactly how, and everybody is scared of touching it.&lt;/p&gt;

&lt;p&gt;How it happens is somewhat simple:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We start with some dev team that build System X&lt;/li&gt;
  &lt;li&gt;Everybody knows everything about X (best case cenario)&lt;/li&gt;
  &lt;li&gt;With new features coming in and members changing (reallocations, retirement, etc), entropy takes place and things get complex&lt;/li&gt;
  &lt;li&gt;X grows in complexity and size, and members don’t know how some parts work&lt;/li&gt;
  &lt;li&gt;Members get scared of touching in some areas of X, fearing the overall impacts (usually the more core and complex features)&lt;/li&gt;
  &lt;li&gt;These “dark areas” grow in number until there are more “fear zones” than “known zones”&lt;/li&gt;
  &lt;li&gt;All development reach really low levels of speed&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By the time of 5, some developers might already be claiming that the system must be rewritten. In 7, the overall development speed reaches a terminal point, in which the business value deliveried is almost null and more developers must be hired. Unfortunatelly, these new folks usually make things worse, because of the already chaotic enviroment.&lt;/p&gt;

&lt;p&gt;(and by “make things worse” I mean that they usually add layers of abstraction to avoid the “fear zones”, which make things even more complex)&lt;/p&gt;

&lt;p&gt;But how can you rewrite your main system? So much time spent in a product to simply “recreate it” doesn’t sound like a good deal.&lt;/p&gt;

&lt;p&gt;(banks, until this day, keep puting more money in COBOL because it’s SO HARD and SO EXPENSIVE to try to rewrite their whole systems that they apparently given up trying. I can’t blame them)&lt;/p&gt;

&lt;p&gt;Thinking about this problem (and how to solve it) we can see that this behaviour will potentially occur in any system. With the acceleration of technology, a new system might become obsolete in less than an year. I’ve seen recently one been called “legacy” in six months. And yes, sometimes it’s just the eagerness of developers to try new things, but this scenario should be analyzed to check it’s veracity.&lt;/p&gt;

&lt;p&gt;With this information in mind, we can reach the next conclusion: in a project that is planned to run for more than a year (I’ll talk about estimates another time :-) ), there is a good possibility that it will be born with the label “legacy” in it. And I mean, any system, not just “system rewrite” projects.&lt;/p&gt;

&lt;p&gt;I remember clearly one of my old experiences, where we had been working with some huge old system and, after big arguments and politics, the dev team could get the approval from business to recreate the system. Entirely, from scratch!&lt;/p&gt;

&lt;p&gt;I was happy with the decision and it seemed the right path. So I went to talk to one of senior programmers about this, and he just asked me “That’s good… but what’s keeping us from not bumping into the same problem in the future?”, and until this day I don’t know what I could have answered him. I believe that this is one of the greatest questions in commercial software development.&lt;/p&gt;

&lt;p&gt;I don’t believe that there’s a way to solve this problem, but I do believe that there are ways to mitigate it. Unit testing goes a long way, but I see it more like a way to help maintenance than to make it easier to rewrite it. I mean, it helps, but if you want to change technology, you will probably throw away the whole suite.&lt;/p&gt;

&lt;p&gt;(but I can’t expect to solve anything in a project that doesn’t have unit tests. It’s the bare minimum in a serious project)&lt;/p&gt;

&lt;p&gt;I believe that the best strategy is to embrace the rewrite idea. Keeping legacy systems running is really expensive, and hiring people and training them to learn something from an old software is even more expensive. Therefore, I think that embracing the idea is the best way.&lt;/p&gt;

&lt;p&gt;“But will l keep rewriting my system all the time? How can I find time to deliver new features?”, I can hear your claims, hipotetical reader, and I understand you.&lt;/p&gt;

&lt;p&gt;The middle ground would be: keeping the systems so small that it’s write and rewrite proccess takes, at maximum, weeks, and not years. To reach that scenario, you’ll need to separate your software in a lot of sub-systems, and I’m not talking about component or plugin architecture. The idea is to have an ecossystem of software, ideally communicating through rest to reinforce the idea of loose connected parts, and to force the developers to reach an ideal interface. To keep it all together, you’ll need, besides the unit testing, complex integration tests, which hits every one of those systems. That way, you’ll could simply throw away one and recreate it without a lot of pain, and keep the guarantee that everything else works.&lt;/p&gt;

&lt;p&gt;Yes, I’m talking about micro-services architecture.
I believe that, today, with cloud in our reach, this is possible and desirable. We can create and destroy VMs in an automated way and keep the whole ecossystem ok. If you can’t use cloud in a nice way, docker and kubernates can be your best friends. What I mean is that you have tools to think about this implementation.&lt;/p&gt;

&lt;p&gt;I understand that micro-services is, today, a buzz word, and if you don’t like it, just call it a service architecture. But the concept is around for quite some time, even the idea of “breaking big problem in a serie of small ones” is the whole core of Object Oriented development. We should think more about it and use this knowledge more often.&lt;/p&gt;</content><author><name>Allan Vital</name></author><summary type="html">So, there’s this thing about your system.</summary></entry><entry><title type="html">Embrace Change</title><link href="http://localhost:4000/embrace-change" rel="alternate" type="text/html" title="Embrace Change" /><published>2015-11-20T16:00:00-02:00</published><updated>2015-11-20T16:00:00-02:00</updated><id>http://localhost:4000/embrace-change</id><content type="html" xml:base="http://localhost:4000/embrace-change">&lt;p&gt;In recent past, Orkut was the main social network in my area. Everybody used it, and everybody loved it. I believe it was the first “real” social network that was massively popular here and there were no signs that it would be replaced by Facebook.&lt;/p&gt;

&lt;p&gt;When launched, the first iPhone revolutionized the industry of smartphones. It was something new and everybody loved it and bought one. Today Android has a bigger market share (&lt;a href=&quot;http://www.kantarworldpanel.com/global/smartphone-os-market-share/&quot;&gt;talking about number of devices&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;And even although Windows was the first in, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Usage_share_of_operating_systems#Public_servers_on_the_Internet&quot;&gt;majority of online servers today are Linux-based&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The idea behind these facts is that even first comers can get behind in the long run. And there are, of course, a lot of reasons for this to happen, but one that always pops out is the easiness to change.&lt;/p&gt;

&lt;p&gt;The only certain in business and technology is that things change. If you are not prepared for it, you will be behind the top competition. I believe that this is the main reason why agile methods work: they embrace the idea that planned things change and that customer needs also change.&lt;/p&gt;

&lt;p&gt;With this in mind, maybe the biggest advice to software companies should be: always be ready to change your planned roadmap.&lt;/p&gt;</content><author><name>Allan Vital</name></author><summary type="html">In recent past, Orkut was the main social network in my area. Everybody used it, and everybody loved it. I believe it was the first “real” social network that was massively popular here and there were no signs that it would be replaced by Facebook.</summary></entry><entry><title type="html">Be careful with the right tool for the right job</title><link href="http://localhost:4000/be-careful-with-the-right-tool-for-the-right-job" rel="alternate" type="text/html" title="Be careful with the right tool for the right job" /><published>2015-11-18T16:00:00-02:00</published><updated>2015-11-18T16:00:00-02:00</updated><id>http://localhost:4000/be-careful-with-the-right-tool-for-the-right-job</id><content type="html" xml:base="http://localhost:4000/be-careful-with-the-right-tool-for-the-right-job">&lt;p&gt;When I started my career I quite never understood the idea of settling down with some language/technology. It always sounded wrong to do it because you have to “&lt;a href=&quot;http://social.technet.microsoft.com/wiki/contents/articles/14403.use-the-right-tool-for-the-right-job.aspx&quot;&gt;use the right tool for the right job&lt;/a&gt;” and “&lt;a href=&quot;http://blog.codinghorror.com/content/images/uploads/2012/06/6a0120a85dcdae970b017742d249d5970d-800wi.jpg&quot;&gt;if it doesn’t look like a nail, don’t use a hammer&lt;/a&gt;”, but today I think that, as aways, the reality is a bit more complex.&lt;/p&gt;

&lt;p&gt;I still think that, as a developer, I am more capable and productive learning more and more languages/platforms/tools/frameworks/etc. With this mindset I have the know-how to suggest new solutions, avoid bad ways and keep my mind sharp, thus, being a better professional.&lt;/p&gt;

&lt;p&gt;However, when it comes to the enterprise world, especially bigger companies, it makes sense to focus on some specific technologies (specially if you didn’t enter the &lt;a href=&quot;http://martinfowler.com/articles/microservices.html&quot;&gt;microservices&lt;/a&gt; team… more about it in another post). And the reasons for this are many:&lt;/p&gt;

&lt;h3 id=&quot;easier-to-hire&quot;&gt;Easier to hire&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.quora.com/How-hard-is-it-to-hire-a-good-developer&quot;&gt;Hiring is a time and money consuming activity&lt;/a&gt;. You can’t expect to hire the first interviewee, and you can’t expect people to enter in your team ready to tackle the hardest problems. Having a smaller stack helps getting people aboard. Instead of listing a lot of technologies and practices in an opening, you can search for someone who has a specific knowledge and various areas of interest.&lt;/p&gt;

&lt;p&gt;It’s like “We need you to know this, and a little bit of this and that” instead of “We need you to know everything”.&lt;/p&gt;

&lt;h3 id=&quot;easier-to-maintain&quot;&gt;Easier to maintain&lt;/h3&gt;

&lt;p&gt;As we know, &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;maintenance is where we spend the biggest amount of time in software development&lt;/a&gt;. Having your systems running in similar technology makes it easier to build skills useful to maintain the whole park.&lt;/p&gt;

&lt;p&gt;The idea is “If you learn this technology in system X, you will have a better time understanding system Y also”.&lt;/p&gt;

&lt;h3 id=&quot;padronization&quot;&gt;Padronization&lt;/h3&gt;

&lt;p&gt;Some tools have an entire ecosystem dedicated to them (like &lt;a href=&quot;http://www.sonarqube.org/&quot;&gt;sonar&lt;/a&gt; -&amp;gt; java, or &lt;a href=&quot;https://codeclimate.com/&quot;&gt;code climate&lt;/a&gt; -&amp;gt; ruby). By standardizing your park you can use the full benefits of metrics for better planning and, also, team member rotation become a reality less painful.&lt;/p&gt;

&lt;p&gt;Think about “We can standardize our pipelines if we use technology X for backends and technology Y for frontends”.&lt;/p&gt;

&lt;h3 id=&quot;mitigate-even-more-the-knowledge-silos&quot;&gt;Mitigate even more the &lt;a href=&quot;http://pt.slideshare.net/rockycode/breaking-down-knowledge-silos&quot;&gt;knowledge silos&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Streching a little bit, I know, but it potencially avoid the “Carl’s the only one that knows how this works”.&lt;/p&gt;

&lt;p&gt;Ideally it would be “everybody can work on any system in the company”.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The list of benefits go on, but you got the idea.&lt;/p&gt;

&lt;p&gt;Again, I still think that developers should be hungry for knowledge but we must be careful to not build an environment which we don’t even know what is written on what and people keep entering and leaving your organization. Sometimes it’s important to think in the long run, focusing on the “if I were to leave the company tomorrow, would it be easy for them to maintain what I’ve done?”.&lt;/p&gt;

&lt;p&gt;Big hugs&lt;/p&gt;</content><author><name>Allan Vital</name></author><summary type="html">When I started my career I quite never understood the idea of settling down with some language/technology. It always sounded wrong to do it because you have to “use the right tool for the right job” and “if it doesn’t look like a nail, don’t use a hammer”, but today I think that, as aways, the reality is a bit more complex.</summary></entry><entry><title type="html">Hello Again</title><link href="http://localhost:4000/hello-again" rel="alternate" type="text/html" title="Hello Again" /><published>2015-11-14T16:00:00-02:00</published><updated>2015-11-14T16:00:00-02:00</updated><id>http://localhost:4000/hello-again</id><content type="html" xml:base="http://localhost:4000/hello-again">&lt;p&gt;Welcome to my new blog! If you came from the &lt;a href=&quot;https://allanvital.wordpress.com/&quot;&gt;old one&lt;/a&gt;, hello again, if not, it’s nice to meet you.&lt;/p&gt;

&lt;p&gt;It was a shame that I didn’t have my blog in my &lt;a href=&quot;http://allanvital.com/&quot;&gt;own server&lt;/a&gt;, but I fixed that now. Also, I’m not using wordpress anymore in favor of &lt;a href=&quot;http://gohugo.io/&quot;&gt;Hugo&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;A long time has passed since my last posts, and I think that I evolved a lot in this meantime. My posts will be, again, about technology, tools and methodologies.&lt;/p&gt;

&lt;p&gt;Big Hugs!&lt;/p&gt;</content><author><name>Allan Vital</name></author><summary type="html">Welcome to my new blog! If you came from the old one, hello again, if not, it’s nice to meet you.</summary></entry></feed>